# Assembly programs
* Exercise 1: The first code takes two arrays of 16-bit values, adds the corresponding elements of the arrays, 
and stores the result in a third array. It uses the load-store architecture to access the memory.
* Exercise 2: The second code is similar to the first, but it uses 32-bit values instead of 16-bit values.
* Exercise 3: The third code is again similar to the first two, but it uses the carry flag to propagate the 
carry between successive additions.
* Exercise 4: The fourth code is identical to the second, but it uses a loop to perform the additions instead 
of doing them one by one.
* Exercise 5: This code is a simple loop that stores the integers 0 to 5 as bytes in an array in memory.
* Exercise 6: This code generates the Fibonacci sequence by storing the first five numbers (0, 1, 2, 3, 5) as bytes in an array in memory. 
It uses a loop to calculate the next number in the sequence by adding the previous two, and continues until the fifth number 
has been calculated and stored in the array.
* Exercise 7: This assembly code performs arithmetic operations on byte values in two arrays and stores the results in 
a third array. It uses loops and subroutines to iterate through the arrays and perform the calculations.
* Exercise 8: This assembly code is similar to the first, but it also includes code to store some of the 
calculated values back into the Const array.
* Exercise 9: This assembly code performs arithmetic operations on two arrays of word values and stores the results 
in a single variable. It uses nested loops to iterate through the arrays and perform the calculations.
* Exercise 10: This code is an implementation of the insertion sort algorithm for sorting an array of bytes stored in memory. 
The sorted array is stored back in memory.
* Exercise 11: This code sorts an array of bytes using the insertion sort algorithm and then tests whether the array is in ascending order.
